// import {
//   app,
//   BrowserWindow,
//   ipcMain,
//   powerMonitor,
//   Notification,
//   Tray,
//   Menu,
// } from "electron";
// import path from "path";
// // import AutoLaunch from 'auto-launch'
// // import settings from 'electron-settings'

// // This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// // plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// // whether you're running in development or production).
// declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
// declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// declare global {
//   interface Window {
//     electronAPI: {
//       getSystemIdleTime: () => number;
//       displayNotification: () => void;
//     };
//   }
// }

// export let mainWindow: BrowserWindow | null = null;
// let tray: Tray | null = null;
// let isQuitting = false;

// // Handle creating/removing shortcuts on Windows when installing/uninstalling.
// if (require("electron-squirrel-startup")) {
//   app.quit();
// }

// // // Create an AutoLaunch instance
// // const autoLauncher = new AutoLaunch({
// //   name: 'Active Pixel',
// //   path: app.getPath('exe'),
// // })

// // // Function to enable or disable auto-launch
// // const setAutoLaunch = async (enable: boolean) => {
// //   if (enable) {
// //     await autoLauncher.enable()
// //   } else {
// //     await autoLauncher.disable()
// //   }
// //   await settings.set('autoLaunch', enable)
// // }

// // // Check the current auto-launch setting and apply it
// // const initAutoLaunch = async () => {
// //   const autoLaunchEnabled = await settings.get('autoLaunch')
// //   if (autoLaunchEnabled) {
// //     await autoLauncher.enable()
// //   } else {
// //     await autoLauncher.disable()
// //   }
// // }

// const createWindow = () => {
//   // Create the browser window.
//   mainWindow = new BrowserWindow({
//     height: 1080,
//     width: 1920,
//     webPreferences: {
//       preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
//     },
//   });

//   // and load the index.html of the app.
//   mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

//   // Open the DevTools in development.
//   if (process.env.NODE_ENV === "development") {
//     mainWindow.webContents.openDevTools();
//   }

//   // // Modify the CSP to allow images from the specified source
//   // mainWindow.webContents.session.webRequest.onHeadersReceived(
//   //   (details, callback) => {
//   //     callback({
//   //       responseHeaders: {
//   //         ...details.responseHeaders,
//   //         'Content-Security-Policy': [
//   //           "default-src 'self' 'unsafe-inline' data:; img-src 'self' https://raw.githubusercontent.com",
//   //         ],
//   //       },
//   //     })
//   //   }
//   // )

//   mainWindow.on("close", (event) => {
//     if (!isQuitting) {
//       event.preventDefault();
//       mainWindow?.hide();
//     }
//   });
// };

// const createTray = () => {
//   console.log(app.getAppPath());
//   tray = new Tray(
//     path.join(app.getAppPath(), "src", "assets", "check-list.png")
//   );
//   const contextMenu = Menu.buildFromTemplate([
//     {
//       label: "Show App",
//       click: () => {
//         mainWindow.show();
//       },
//     },
//     {
//       label: "Quit",
//       click: () => {
//         isQuitting = true;
//         app.quit();
//         mainWindow = null;
//       },
//     },
//   ]);
//   tray.setToolTip("My Electron App");
//   tray.setContextMenu(contextMenu);
// };

// // This method will be called when Electron has finished
// // initialization and is ready to create browser windows.
// // Some APIs can only be used after this event occurs.
// app.on("ready", async () => {
//   createWindow();
//   createTray();
//   // await initAutoLaunch()
// });

// // Quit when all windows are closed, except on macOS. There, it's common
// // for applications and their menu bar to stay active until the user quits
// // explicitly with Cmd + Q.
// app.on("window-all-closed", () => {
//   if (process.platform !== "darwin") {
//     app.quit();
//   }
// });

// app.on("activate", () => {
//   // On OS X it's common to re-create a window in the app when the
//   // dock icon is clicked and there are no other windows open.
//   if (mainWindow === null) {
//     createWindow();
//   } else {
//     mainWindow.show();
//   }
// });

// ipcMain.handle("get-system-idle-time", async () =>
//   powerMonitor.getSystemIdleTime()
// );

// // In this file you can include the rest of your app's specific main process
// // code. You can also put them in separate files and import them here.
// import "./handlers/notification";

import { app, BrowserWindow, Tray, Menu } from "electron";
import { join } from "path";
import {
  startActivityLogger,
  stopActivityLogger,
} from "./utils/activityLogger";
import { getSetting } from "./utils/store";

declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

declare global {
  interface Window {
    electronAPI: {
      getSystemIdleTime: () => number;
      displayNotification: () => void;
      getSetting: (key: string) => Promise<any>;
      setSetting: (key: string, value: any) => Promise<void>;
    };
  }
}

let mainWindow: BrowserWindow | null;
let tray: Tray | null;
let isQuitting = false;

if (!app.requestSingleInstanceLock()) {
  app.quit();
} else {
  app.on("second-instance", () => {
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
    }
  });

  const createWindow = () => {
    mainWindow = new BrowserWindow({
      width: 800,
      height: 600,
      webPreferences: {
        nodeIntegration: true,
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      },
    });

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    // Open the DevTools in development.
    if (process.env["NODE_ENV"] === "development") {
      mainWindow.webContents.openDevTools();
    }

    mainWindow.on("close", (event) => {
      if (!isQuitting) {
        event.preventDefault();
        mainWindow?.hide();
      }
    });
  };

  const createTray = () => {
    console.log(app.getAppPath());
    tray = new Tray(join(app.getAppPath(), "src", "assets", "check-list.png"));
    const contextMenu = Menu.buildFromTemplate([
      {
        label: "Show App",
        click: () => {
          if (mainWindow) {
            if (mainWindow.isMinimized()) mainWindow.restore();
            mainWindow.focus();
          }
        },
      },
      {
        label: "Quit",
        click: () => {
          isQuitting = true;
          app.quit();
        },
      },
    ]);
    tray.setToolTip("Active Pixel");
    tray.setContextMenu(contextMenu);
  };

  app.on("ready", async () => {
    createWindow();
    createTray();

    const displayUnproductiveNotifications = await getSetting(
      "displayUnproductiveNotifications"
    );
    console.log(
      "displayUnproductiveNotifications",
      displayUnproductiveNotifications
    );
    if (displayUnproductiveNotifications) {
      startActivityLogger();
    }

    // [
    //   {
    //     time: "*/5 * * * *",
    //     title: "5 min has passed",
    //     body: "Time to get to work!",
    //   },
    //   {
    //     time: "48 12 * * *",
    //     title: "It's 12:48",
    //     body: "Time to go home!",
    //   },
    // ].forEach((scheduleConfig) => {
    //   schedule.scheduleJob(scheduleConfig.time, async () => {
    //     const notification = new Notification({
    //       title: scheduleConfig.title,
    //       body: scheduleConfig.body,
    //     });
    //     notification.on("click", () => {
    //       console.log("Notification clicked");
    //     });
    //     notification.show();
    //   });
    // });
    // await initAutoLaunch()
  });

  app.on("before-quit", () => {
    stopActivityLogger();
  });

  app.on("window-all-closed", () => {
    if (process.platform !== "darwin") {
      app.quit();
    }
  });
}

import "./handlers/settings";
